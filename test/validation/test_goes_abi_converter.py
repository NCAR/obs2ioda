import os
import subprocess
import numpy as np
import pytest
from pathlib import Path
from conftest import extract_structure, format_netcdf_assert_msg
from FilePathConfig import WRITE_IODA_V3_TEST_EXECUTABLE_PATH, VALIDATION_TEST_DIRECTORY

@pytest.fixture(scope="module", autouse=True)
def generate_test_output():
    """
    Calls
    Fixture to generate test output by calling the Fortran executable.
    """
    executable = Path(WRITE_IODA_V3_TEST_EXECUTABLE_PATH)
    test_directory = Path(VALIDATION_TEST_DIRECTORY) / "data/goes_abi/write_ioda_v3"
    output_directory = test_directory / "output"
    output_directory.mkdir(parents=True, exist_ok=True)
    output_file = output_directory / "write_ioda_v3.nc"
    reference_file = test_directory / "reference/write_ioda_v3.nc"
    if not executable.exists():
        raise FileNotFoundError(f"Missing Fortran test executable: {executable}")
    if output_file.exists():
        output_file.unlink()
    if not reference_file.exists():
        raise FileNotFoundError(f"Missing reference file: {reference_file}")
    result = subprocess.run([str(executable), str(output_directory) ], capture_output=True, text=True)
    if result.returncode != 0:
        raise RuntimeError(f"Test executable failed:\n{result.stderr}")

    if not output_file.exists():
        raise FileNotFoundError("Test executable did not produce output file")

    yield
    output_file.unlink(missing_ok=True)
    os.rmdir(output_directory)



@pytest.mark.goes_abi
def test_write_ioda_v3():
    """
    Compare the NetCDF output file generated by the Fortran module with a known reference.
    """
    test_directory = Path(VALIDATION_TEST_DIRECTORY) / "data/goes_abi/write_ioda_v3"
    output_file = test_directory / "output/write_ioda_v3.nc"
    reference_file = test_directory / "reference/write_ioda_v3.nc"
    ref_struct = extract_structure(reference_file)
    test_struct = extract_structure(output_file)

    for group in ref_struct:
        # Compare variable names
        ref_vars = set(ref_struct[group].keys())
        test_vars = set(test_struct[group].keys())
        assert ref_vars == test_vars, format_netcdf_assert_msg(
            output_file.name, group, "<ALL>", "Variable name mismatch", ref_vars, test_vars
        )

        for varname in ref_vars:
            ref = ref_struct[group][varname]
            test = test_struct[group][varname]

            # Dtype
            assert ref["dtype"] == test["dtype"], format_netcdf_assert_msg(
                output_file.name, group, varname, "Dtype mismatch", ref["dtype"], test["dtype"]
            )

            # Dimensions
            assert ref["dimensions"] == test["dimensions"], format_netcdf_assert_msg(
                output_file.name, group, varname, "Dimension mismatch", ref["dimensions"], test["dimensions"]
            )

            # Attributes
            assert ref["attributes"] == test["attributes"], format_netcdf_assert_msg(
                output_file.name, group, varname, "Attribute mismatch", ref["attributes"], test["attributes"]
            )

            # Data
            if np.issubdtype(ref["dtype"], np.number):
                assert np.allclose(ref["data"], test["data"], rtol=1e-5, atol=1e-6), format_netcdf_assert_msg(
                    output_file.name, group, varname, "Numerical data mismatch", ref["data"], test["data"]
                )
            elif np.issubdtype(ref["dtype"], np.str_):
                for i, (rval, tval) in enumerate(zip(ref["data"].flatten(), test["data"].flatten())):
                    assert rval == tval, format_netcdf_assert_msg(
                        output_file.name, group, varname,
                        f"String mismatch at index {i}", rval, tval
                    )
            else:
                assert np.array_equal(ref["data"], test["data"]), format_netcdf_assert_msg(
                    output_file.name, group, varname, "Data mismatch", ref["data"], test["data"]
                )
