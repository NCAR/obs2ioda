"""
Test suite for validating NCEP PREPBUFR BUFR IODA outputs.

This module uses pytest to compare NetCDF outputs generated by the conversion process
against known-good reference files. It validates group structure, variable metadata,
attributes, and data values.

All tests are marked with @pytest.mark.ncep_prepbufr_bufr for selective execution.
"""

import numpy as np
from typing import Tuple
from netCDF4 import Dataset
from pathlib import Path
from test_utils.utils import extract_structure, format_netcdf_assert_msg
import pytest

@pytest.mark.ncep_prepbufr_bufr
def test_group_names_match(ncep_prepbufr_bufr_file_pair: Tuple[Path, Path]) -> None:
    """
    Ensure all top-level group names match between reference and test files.

    Parameters
    ----------
    ncep_prepbufr_bufr_file_pair : Tuple[Path, Path]
        A tuple of (reference_file_path, test_file_path).
    """
    ref_path, test_path = ncep_prepbufr_bufr_file_pair
    ref_groups = set(extract_structure(ref_path).keys())
    test_groups = set(extract_structure(test_path).keys())
    assert ref_groups == test_groups, (
        f"[NetCDF Mismatch] File: '{test_path.name}'\n"
        f"Group name mismatch\nReference: {ref_groups}\nTest:      {test_groups}"
    )

@pytest.mark.ncep_prepbufr_bufr
def test_variable_names_match(ncep_prepbufr_bufr_file_pair: Tuple[Path, Path]) -> None:
    """
    Ensure all variable names in each group match between reference and test files.

    Parameters
    ----------
    ncep_prepbufr_bufr_file_pair : Tuple[Path, Path]
        A tuple of (reference_file_path, test_file_path).
    """
    ref_path, test_path = ncep_prepbufr_bufr_file_pair
    ref_struct = extract_structure(ref_path)
    test_struct = extract_structure(test_path)
    for group in ref_struct:
        ref_vars = set(ref_struct[group].keys())
        test_vars = set(test_struct[group].keys())
        assert ref_vars == test_vars, (
            f"[NetCDF Mismatch] File: '{test_path.name}' | Group: '{group}'\n"
            f"Variable name mismatch\nReference: {ref_vars}\nTest:      {test_vars}"
        )

@pytest.mark.ncep_prepbufr_bufr
def test_variable_dtype_and_dimensions_match(ncep_prepbufr_bufr_file_pair: Tuple[Path, Path]) -> None:
    """
    Validate that variable data types and dimensions match exactly between reference and test files.

    Parameters
    ----------
    ncep_prepbufr_bufr_file_pair : Tuple[Path, Path]
        A tuple of (reference_file_path, test_file_path).
    """
    ref_path, test_path = ncep_prepbufr_bufr_file_pair
    ref_struct = extract_structure(ref_path)
    test_struct = extract_structure(test_path)
    for group in ref_struct:
        for varname in ref_struct[group]:
            ref = ref_struct[group][varname]
            test = test_struct[group][varname]
            assert ref["dtype"] == test["dtype"], format_netcdf_assert_msg(
                test_path.name, group, varname, "Dtype mismatch", ref["dtype"], test["dtype"]
            )
            assert ref["dimensions"] == test["dimensions"], format_netcdf_assert_msg(
                test_path.name, group, varname, "Dimension mismatch", ref["dimensions"], test["dimensions"]
            )

@pytest.mark.ncep_prepbufr_bufr
def test_variable_attributes_match(ncep_prepbufr_bufr_file_pair: Tuple[Path, Path]) -> None:
    """
    Check that attribute *names* for each variable match between reference and test files.

    Parameters
    ----------
    ncep_prepbufr_bufr_file_pair : Tuple[Path, Path]
        A tuple of (reference_file_path, test_file_path).
    """
    ref_path, test_path = ncep_prepbufr_bufr_file_pair
    ref_struct = extract_structure(ref_path)
    test_struct = extract_structure(test_path)
    for group in ref_struct:
        for varname in ref_struct[group]:
            ref_attrs = ref_struct[group][varname]["attributes"]
            test_attrs = test_struct[group][varname]["attributes"]
            assert ref_attrs == test_attrs, format_netcdf_assert_msg(
                test_path.name, group, varname, "Attribute name set mismatch", ref_attrs, test_attrs
            )

@pytest.mark.ncep_prepbufr_bufr
def test_variable_attribute_values_match(ncep_prepbufr_bufr_file_pair: Tuple[Path, Path]) -> None:
    """
    Check that attribute *values* for each variable match exactly between reference and test files.

    Parameters
    ----------
    ncep_prepbufr_bufr_file_pair : Tuple[Path, Path]
        A tuple of (reference_file_path, test_file_path).
    """
    ref_path, test_path = ncep_prepbufr_bufr_file_pair
    with Dataset(ref_path.as_posix(), "r") as ref_ds, Dataset(test_path.as_posix(), "r") as test_ds:
        def recurse(ref_grp, test_grp) -> None:
            for group_name in ref_grp.groups:
                recurse(ref_grp.groups[group_name], test_grp.groups[group_name])
            for varname in ref_grp.variables:
                ref_var = ref_grp.variables[varname]
                test_var = test_grp.variables[varname]
                for attr in set(ref_var.ncattrs()) & set(test_var.ncattrs()):
                    ref_val = ref_var.getncattr(attr)
                    test_val = test_var.getncattr(attr)
                    if isinstance(ref_val, np.ndarray) or isinstance(test_val, np.ndarray):
                        assert np.array_equal(ref_val, test_val), format_netcdf_assert_msg(
                            test_path.name, ref_grp.path, varname,
                            f"Attribute array value mismatch for '{attr}'", ref_val, test_val
                        )
                    else:
                        assert ref_val == test_val, format_netcdf_assert_msg(
                            test_path.name, ref_grp.path, varname,
                            f"Attribute value mismatch for '{attr}'", ref_val, test_val
                        )
        recurse(ref_ds, test_ds)

@pytest.mark.ncep_prepbufr_bufr
def test_variable_data_match(ncep_prepbufr_bufr_file_pair: Tuple[Path, Path]) -> None:
    """
    Compare actual variable data values (numeric or string) across reference and test files.

    Parameters
    ----------
    ncep_prepbufr_bufr_file_pair : Tuple[Path, Path]
        A tuple of (reference_file_path, test_file_path).
    """
    ref_path, test_path = ncep_prepbufr_bufr_file_pair
    ref_struct = extract_structure(ref_path)
    test_struct = extract_structure(test_path)
    for group in ref_struct:
        if group == "/":
            continue
        for varname in ref_struct[group]:
            ref = ref_struct[group][varname]
            test = test_struct[group][varname]
            dtype = ref["dtype"]
            ref_data = ref["data"]
            test_data = test["data"]
            if ref_data.size == 0 and test_data.size == 0:
                continue
            if np.issubdtype(dtype, np.str_):
                for i, (r, o) in enumerate(zip(ref_data.flatten(), test_data.flatten())):
                    if r == "-" or o == "-":
                        continue
                    assert r == o, format_netcdf_assert_msg(
                        test_path.name, group, varname,
                        f"String mismatch at index {i}", r, o
                    )
            elif np.issubdtype(dtype, np.number):
                assert np.ma.allclose(ref_data.flatten(), test_data.flatten(),
                                      masked_equal=True, atol=1e-6, rtol=1e-5), (
                    format_netcdf_assert_msg(
                        test_path.name, group, varname,
                        "Numeric data mismatch", ref_data, test_data
                    )
                )
            else:
                assert np.array_equal(ref_data, test_data), format_netcdf_assert_msg(
                    test_path.name, group, varname,
                    "Non-numeric array mismatch", ref_data, test_data
                )

@pytest.mark.ncep_prepbufr_bufr
def test_global_attributes_match(ncep_prepbufr_bufr_file_pair: Tuple[Path, Path]) -> None:
    """
    Validate that all global attributes match in name and value between files.

    Parameters
    ----------
    ncep_prepbufr_bufr_file_pair : Tuple[Path, Path]
        A tuple of (reference_file_path, test_file_path).
    """
    ref_path, test_path = ncep_prepbufr_bufr_file_pair
    with Dataset(ref_path.as_posix(), "r") as ref_ds, Dataset(test_path.as_posix(), "r") as test_ds:
        ref_attrs = set(ref_ds.ncattrs())
        test_attrs = set(test_ds.ncattrs())
        assert ref_attrs == test_attrs, format_netcdf_assert_msg(
            test_path.name, "/", "global", "Global attribute name mismatch", ref_attrs, test_attrs
        )
        for attr in ref_attrs:
            ref_val = ref_ds.getncattr(attr)
            test_val = test_ds.getncattr(attr)
            if isinstance(ref_val, np.ndarray) or isinstance(test_val, np.ndarray):
                assert np.array_equal(ref_val, test_val), format_netcdf_assert_msg(
                    test_path.name, "/", "global",
                    f"Global attribute array value mismatch for '{attr}'", ref_val, test_val
                )
            else:
                assert ref_val == test_val, format_netcdf_assert_msg(
                    test_path.name, "/", "global",
                    f"Global attribute value mismatch for '{attr}'", ref_val, test_val
                )